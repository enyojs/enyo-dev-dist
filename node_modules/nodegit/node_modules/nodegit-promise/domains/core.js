'use strict';

var asap = require('asap')

function noop() {};

// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable

// All `_` prefixed properties will be reduced to `_{random number}`
// at build time to obfuscate them and discourage their use.
// We don't use symbols or Object.defineProperty to fully hide them
// because the performance isn't good enough.


// to avoid using try/catch inside critical functions, we
// extract them to here.
var LAST_ERROR = null;
var IS_ERROR = {};
function getThen(obj) {
  try {
    return obj.then;
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

function tryCallOne(fn, a) {
  try {
    return fn(a);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}
function tryCallTwo(fn, a, b) {
  try {
    fn(a, b);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

module.exports = Promise;
function Promise(fn) {
  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')
  if (typeof fn !== 'function') throw new TypeError('not a function')
  this._23 = 0;
  this._78 = null;
  this._29 = [];
  if (fn === noop) return;
  doResolve(fn, this);
}
Promise.prototype._7 = function (onFulfilled, onRejected) {
  var self = this;
  return new this.constructor(function (resolve, reject) {
    var res = new Promise(noop);
    res.then(resolve, reject);
    self._3(new Handler(onFulfilled, onRejected, res));
  });
};
Promise.prototype.then = function(onFulfilled, onRejected) {
  if (this.constructor !== Promise) return this._7(onFulfilled, onRejected);
  var res = new Promise(noop);
  this._3(new Handler(onFulfilled, onRejected, res));
  return res;
};
Promise.prototype._3 = function(deferred) {
  if (this._23 === 3) {
    this._78._3(deferred);
    return;
  }
  if (this._23 === 0) {
    this._29.push(deferred);
    return;
  }
  var state = this._23;
  var value = this._78;
  asap(function() {
    var cb = state === 1 ? deferred.onFulfilled : deferred.onRejected
    if (cb === null) {
      (state === 1 ? deferred.promise._67(value) : deferred.promise._30(value))
      return
    }
    var ret = tryCallOne(cb, value);
    if (ret === IS_ERROR) {
      deferred.promise._30(LAST_ERROR)
    } else {
      deferred.promise._67(ret)
    }
  });
};
Promise.prototype._67 = function(newValue) {
  //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
  if (newValue === this) {
    return this._30(new TypeError('A promise cannot be resolved with itself.'))
  }
  if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
    var then = getThen(newValue);
    if (then === IS_ERROR) {
      return this._30(LAST_ERROR);
    }
    if (
      then === this.then &&
      newValue instanceof Promise &&
      newValue._3 === this._3
    ) {
      this._23 = 3;
      this._78 = newValue;
      for (var i = 0; i < this._29.length; i++) {
        newValue._3(this._29[i]);
      }
      return;
    } else if (typeof then === 'function') {
      doResolve(then.bind(newValue), this)
      return
    }
  }
  this._23 = 1
  this._78 = newValue
  this._27()
}

Promise.prototype._30 = function (newValue) {
  this._23 = 2
  this._78 = newValue
  this._27()
}
Promise.prototype._27 = function () {
  for (var i = 0; i < this._29.length; i++)
    this._3(this._29[i])
  this._29 = null
}

/**
 * Synchronous Inspection
 */
Promise.prototype.isPending = function () {
  return this._23 === 0;
}
Promise.prototype.isFulfilled = function () {
  return this._23 === 1 || this._23 === 3;
}
Promise.prototype.isRejected = function () {
  return this._23 === 2;
}
Promise.prototype.value = function () {
  if (!this.isFulfilled()) {
    throw new Error('Cannot get a value of an unfulfilled promise.')
  }

  return this._78;
}
Promise.prototype.reason = function () {
  if (!this.isRejected()) {
    throw new Error('Cannot get a rejection reason of a non-rejected promise.')
  }

  return this._78;
}


function Handler(onFulfilled, onRejected, promise){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
  this.onRejected = typeof onRejected === 'function' ? onRejected : null
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, promise) {
  var done = false;
  var res = tryCallTwo(fn, function (value) {
    if (done) return
    done = true
    promise._67(value)
  }, function (reason) {
    if (done) return
    done = true
    promise._30(reason)
  })
  if (!done && res === IS_ERROR) {
    done = true
    promise._30(LAST_ERROR)
  }
}
